@startuml

Title WebServ - Classes Overview

WebServer o-- VirtualServer

class WebServer
{
	-int _epollFd;
	-std::set<uint16_t> _ports;
	-vector<VirtualServer*> _virtualServers;
	-map<int, VirtualServer*> _connections;
	-std::map<int, std::string> _clientBuffers;
	-std::map<int, Request> _requests;
	--

	+Webserver(void);
	+\~Webserver(void);
	+void init(void);
	+void run(void);

	-void setUpSockets(std::set<uint16_t> ports);
	-int acceptConnection(int epollFd);

	..Not yet sure..
	-preprocessRequest(int connectionFd);
	-dispatchRequestHandling(int connectionFd);
}

note right of WebServer::preprocessRequest
if there is no Request associated with connection fd in _requests then
	create instance of Request and adds to _requests
	call method to do initial parsing passing the request and _clientBuffer[fd] as reference
else
	recover Request object from _requests
	if Request._parsedHeader is false
		call method to do initial parsing, passing the request and _clientBuffers[fd] as reference
end note

note right of WebServer::dispatchRequestHandling
based on request, identify virtualServer and add to _connections
call virtualServer method that will parse the rest of the request
most likely will receive reference to buffer and to partially filled request
end note


class VirtualServer
{
	-int _port;
	-int _serverFd;
	-std::string _name;
	-std::string _root;
	'allowed methods
	'other things

	+VirtualServer(int port);
	+\~VirtualServer(void);
	+void processRequest(int connectionFd);
	+int getServerFd(void);
}

class	"nRequest"
{
	+std::string _requestLine;
	+std::map<std::string, std::string> _headerFields;
	+std::string _body;

	+std::string _method;
	+std::string _requestTarget;

	+bool _parsedRequestLine;
	+bool _parsedHeader;
	+bool _parsedBody;
}

package "namespace Utils"
{
	object functions{
		str::string& trim(std::string& str);
		std::string getNextLineRN(std::string& buffer);
		std::string removeCRLF(std::string& fieldValue);
	}
}

@enduml
